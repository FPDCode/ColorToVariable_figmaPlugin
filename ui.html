<!DOCTYPE html>
<html>
<head>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-size: 12px;
      color: #333;
    }
    .tabs {
      display: flex;
      border-bottom: 1px solid #e0e0e0;
    }
    .tab {
      flex: 1;
      padding: 12px;
      text-align: center;
      font-weight: 500;
      cursor: pointer;
      background: #f5f5f5;
      border: none;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab:hover {
      background: #eee;
    }
    .tab.active {
      background: white;
      border-bottom-color: #18a0fb;
      color: #18a0fb;
    }
    .tab-content {
      padding: 16px;
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    h3 {
      margin: 0 0 12px 0;
      font-size: 13px;
      font-weight: 600;
    }
    .form-group {
      margin-bottom: 16px;
    }
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
    }
    select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      background: white;
    }
    button.primary {
      width: 100%;
      padding: 10px;
      background: #18a0fb;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }
    button.primary:hover {
      background: #0d8ae0;
    }
    button.primary:active {
      background: #0b7ac9;
    }
    button.primary:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .message {
      margin-top: 12px;
      padding: 8px;
      border-radius: 4px;
      font-size: 11px;
      display: none;
    }
    .message.success {
      background: #e6f7e6;
      color: #2d7a2d;
      border: 1px solid #a5d6a5;
    }
    .message.error {
      background: #ffe6e6;
      color: #c92a2a;
      border: 1px solid #faa;
    }
    .hint {
      font-size: 11px;
      color: #666;
      margin-top: 4px;
    }
    .mode-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    .mode-btn {
      flex: 1;
      padding: 8px 4px;
      border: 2px solid #e0e0e0;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      color: #666;
      transition: all 0.2s;
    }
    .mode-btn:hover {
      border-color: #18a0fb;
      background: #f0f9ff;
    }
    .mode-btn.active {
      border-color: #18a0fb;
      background: #e6f4ff;
      color: #18a0fb;
    }
    .mode-icon {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mode-icon.light {
      background: linear-gradient(135deg, #fff 50%, #f0f0f0 50%);
      border: 1px solid #ddd;
    }
    .mode-icon.dark {
      background: linear-gradient(135deg, #333 50%, #1a1a1a 50%);
      border: 1px solid #555;
    }
    .mode-icon.ic-light {
      background: #fff;
      border: 2px solid #000;
    }
    .mode-icon.ic-dark {
      background: #000;
      border: 2px solid #fff;
    }
    .hex-input-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .color-preview {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fff;
      flex-shrink: 0;
    }
    .hex-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
    }
    .opacity-input {
      width: 48px;
      padding: 8px 4px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
      text-align: center;
      -moz-appearance: textfield;
    }
    .opacity-input::-webkit-outer-spin-button,
    .opacity-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    .opacity-suffix {
      font-size: 12px;
      color: #666;
      margin-left: -4px;
    }
    .text-input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 12px;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
      margin-top: 12px;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 6px;
    }
    .preview-swatch {
      aspect-ratio: 1;
      border-radius: 4px;
      border: 1px solid #ddd;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding: 2px;
    }
    .preview-swatch span {
      font-size: 8px;
      color: #666;
      background: rgba(255,255,255,0.8);
      padding: 1px 3px;
      border-radius: 2px;
    }
    .switch-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .switch-label {
      font-weight: 500;
    }
    .switch {
      position: relative;
      width: 36px;
      height: 20px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.2s;
      border-radius: 20px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.2s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #18a0fb;
    }
    input:checked + .slider:before {
      transform: translateX(16px);
    }
    .output-mode-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
    }
    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-weight: normal;
      font-size: 11px;
      cursor: pointer;
    }
    .checkbox-label input[type="checkbox"] {
      width: 14px;
      height: 14px;
      margin: 0;
      cursor: pointer;
    }
    .suggestions-list {
      max-height: 320px;
      overflow-y: auto;
      margin-top: 12px;
    }
    .suggestion-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px;
      background: #f9f9f9;
      border-radius: 6px;
      margin-bottom: 6px;
      font-size: 11px;
    }
    .suggestion-swatch {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid #ddd;
      flex-shrink: 0;
    }
    .suggestion-info {
      flex: 1;
      min-width: 0;
    }
    .suggestion-layer {
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .suggestion-var {
      color: #666;
      font-size: 10px;
    }
    .suggestion-delta {
      color: #999;
      font-size: 10px;
    }
    .suggestion-actions {
      display: flex;
      gap: 4px;
    }
    .btn-small {
      padding: 4px 8px;
      font-size: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .btn-accept {
      background: #18a0fb;
      color: white;
    }
    .btn-accept:hover {
      background: #0d8ae0;
    }
    .btn-skip {
      background: #e0e0e0;
      color: #666;
    }
    .btn-skip:hover {
      background: #ccc;
    }
    .scan-stats {
      padding: 8px;
      background: #e6f4ff;
      border-radius: 6px;
      margin-bottom: 12px;
      font-size: 11px;
      color: #0d8ae0;
    }
  </style>
</head>
<body>
  <div class="tabs">
    <button class="tab active" data-tab="create">Create</button>
    <button class="tab" data-tab="generate">Generate</button>
    <button class="tab" data-tab="interpolate">Interpolate</button>
    <button class="tab" data-tab="modemaker">Modes</button>
    <button class="tab" data-tab="connect">Connect</button>
  </div>

  <!-- Tab 1: Create Variables -->
  <div id="create-tab" class="tab-content active">
    <h3>Layers → Variables</h3>
    <div class="form-group">
      <label for="collection">Collection</label>
      <select id="collection">
        <option value="">Create new collection</option>
      </select>
      <div class="hint">Select a collection or create a new one</div>
    </div>
    <button id="create" class="primary">Create Variables</button>
    <div id="create-message" class="message"></div>
  </div>

  <!-- Tab 2: Generate Layers -->
  <div id="generate-tab" class="tab-content">
    <h3>Variables → Layers</h3>
    <div class="form-group">
      <label for="gen-collection">Collection</label>
      <select id="gen-collection">
        <option value="" disabled selected>Select a collection</option>
      </select>
      <div class="hint">Creates 200×200 rectangles for each color variable</div>
    </div>
    <div class="switch-row">
      <span class="switch-label">Bind variables to fills</span>
      <label class="switch">
        <input type="checkbox" id="bind-variables">
        <span class="slider"></span>
      </label>
    </div>
    <button id="generate" class="primary" disabled>Generate Layers</button>
    <div id="generate-message" class="message"></div>
  </div>

  <!-- Tab 3: Interpolate Colors -->
  <div id="interpolate-tab" class="tab-content">
    <h3>Keys → Color Scale</h3>
    <div class="form-group">
      <label for="interpolate-collection">Collection</label>
      <select id="interpolate-collection">
        <option value="">Create new collection</option>
      </select>
      <div class="hint">Select key colors (e.g., 300, 500 Light, 500 Dark, 700) to generate full 000-1000 scale</div>
    </div>
    <button id="interpolate" class="primary">Interpolate Colors</button>
    <div id="interpolate-message" class="message"></div>
  </div>

  <!-- Tab 5: Mode Maker -->
  <div id="modemaker-tab" class="tab-content">
    <h3>Hex → Light/Dark Modes</h3>
    
    <div class="form-group">
      <label for="mode-collection">Collection</label>
      <select id="mode-collection">
        <option value="">Create new collection</option>
      </select>
    </div>

    <div class="form-group">
      <label>Input Mode</label>
      <div class="mode-selector">
        <button class="mode-btn active" data-mode="Light">
          <div class="mode-icon light"></div>
          <span>Light</span>
        </button>
        <button class="mode-btn" data-mode="Dark">
          <div class="mode-icon dark"></div>
          <span>Dark</span>
        </button>
        <button class="mode-btn" data-mode="IC - Light">
          <div class="mode-icon ic-light"></div>
          <span>IC - Light</span>
        </button>
        <button class="mode-btn" data-mode="IC - Dark">
          <div class="mode-icon ic-dark"></div>
          <span>IC - Dark</span>
        </button>
      </div>
    </div>

    <div class="form-group">
      <label for="hex-input">Hex Color</label>
      <div class="hex-input-row">
        <div id="color-preview" class="color-preview"></div>
        <input type="text" id="hex-input" class="hex-input" placeholder="FF383C" maxlength="7">
        <input type="number" id="opacity-input" class="opacity-input" value="100" min="1" max="100">
        <span class="opacity-suffix">%</span>
      </div>
    </div>

    <div class="form-group">
      <label for="var-name">Variable Name</label>
      <input type="text" id="var-name" class="text-input" placeholder="Colors/Red">
      <div class="hint">Use / for groups (e.g., Backgrounds/Primary)</div>
    </div>

    <div class="form-group">
      <label>Output Modes</label>
      <div class="output-mode-checkboxes">
        <label class="checkbox-label">
          <input type="checkbox" id="output-all" checked> All
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="output-light" checked> Light
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="output-dark" checked> Dark
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="output-ic-light" checked> IC-Light
        </label>
        <label class="checkbox-label">
          <input type="checkbox" id="output-ic-dark" checked> IC-Dark
        </label>
      </div>
      <label class="checkbox-label" style="margin-top: 8px;">
        <input type="checkbox" id="mirror-ic-modes"> Mirror IC modes (use Light/Dark values)
      </label>
    </div>

    <div class="preview-grid" id="preview-grid">
      <div class="preview-swatch" id="preview-light" style="background:#ccc"><span>Light</span></div>
      <div class="preview-swatch" id="preview-dark" style="background:#ccc"><span>Dark</span></div>
      <div class="preview-swatch" id="preview-ic-light" style="background:#ccc"><span>IC - L</span></div>
      <div class="preview-swatch" id="preview-ic-dark" style="background:#ccc"><span>IC - D</span></div>
    </div>

    <button id="generate-modes" class="primary" style="margin-top:12px">Generate Mode Colors</button>
    <div id="modemaker-message" class="message"></div>
  </div>

  <!-- Tab 6: Connect Colors -->
  <div id="connect-tab" class="tab-content">
    <h3>Auto-Connect Colors</h3>
    <div class="form-group">
      <label for="connect-collection">Match Against Collection</label>
      <select id="connect-collection">
        <option value="" disabled selected>Select a collection</option>
      </select>
      <div class="hint">Select layers or scan entire page. Exact matches auto-connect, close matches (Delta E &lt; 10) shown below.</div>
    </div>
    <button id="scan-colors" class="primary" disabled>Scan Colors</button>
    <div id="connect-message" class="message"></div>
    <div id="scan-stats" class="scan-stats" style="display:none"></div>
    <div id="suggestions-list" class="suggestions-list"></div>
  </div>

  <script>
    // Tab switching
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => {
      tab.onclick = () => {
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tab.dataset.tab + '-tab').classList.add('active');
      };
    });

    // Elements
    const collectionSelect = document.getElementById('collection');
    const createButton = document.getElementById('create');
    const createMessageDiv = document.getElementById('create-message');
    
    const genCollectionSelect = document.getElementById('gen-collection');
    const generateButton = document.getElementById('generate');
    const generateMessageDiv = document.getElementById('generate-message');

    const interpolateCollectionSelect = document.getElementById('interpolate-collection');
    const interpolateButton = document.getElementById('interpolate');
    const interpolateMessageDiv = document.getElementById('interpolate-message');

    // Connect elements
    const connectCollectionSelect = document.getElementById('connect-collection');
    const scanColorsButton = document.getElementById('scan-colors');
    const connectMessageDiv = document.getElementById('connect-message');
    const scanStatsDiv = document.getElementById('scan-stats');
    const suggestionsListDiv = document.getElementById('suggestions-list');

    // Mode Maker elements
    const modeCollectionSelect = document.getElementById('mode-collection');
    const hexInput = document.getElementById('hex-input');
    const opacityInput = document.getElementById('opacity-input');
    const varNameInput = document.getElementById('var-name');
    const colorPreview = document.getElementById('color-preview');
    const generateModesButton = document.getElementById('generate-modes');
    const modemakerMessageDiv = document.getElementById('modemaker-message');
    const modeBtns = document.querySelectorAll('.mode-btn');
    let selectedMode = 'Light';

    // Output mode checkboxes
    const outputAllCheckbox = document.getElementById('output-all');
    const outputLightCheckbox = document.getElementById('output-light');
    const outputDarkCheckbox = document.getElementById('output-dark');
    const outputIcLightCheckbox = document.getElementById('output-ic-light');
    const outputIcDarkCheckbox = document.getElementById('output-ic-dark');
    const individualOutputCheckboxes = [outputLightCheckbox, outputDarkCheckbox, outputIcLightCheckbox, outputIcDarkCheckbox];
    const mirrorIcModesCheckbox = document.getElementById('mirror-ic-modes');

    // Mirror IC modes checkbox triggers preview update
    mirrorIcModesCheckbox.onchange = () => {
      updateColorPreview();
    };

    // "All" checkbox toggles all others
    outputAllCheckbox.onchange = () => {
      individualOutputCheckboxes.forEach(cb => cb.checked = outputAllCheckbox.checked);
      updatePreviewVisibility();
    };

    // Individual checkboxes update "All" state
    individualOutputCheckboxes.forEach(cb => {
      cb.onchange = () => {
        outputAllCheckbox.checked = individualOutputCheckboxes.every(c => c.checked);
        updatePreviewVisibility();
      };
    });

    function getSelectedOutputModes() {
      const modes = [];
      if (outputLightCheckbox.checked) modes.push('Light');
      if (outputDarkCheckbox.checked) modes.push('Dark');
      if (outputIcLightCheckbox.checked) modes.push('IC - Light');
      if (outputIcDarkCheckbox.checked) modes.push('IC - Dark');
      return modes;
    }

    function updatePreviewVisibility() {
      document.getElementById('preview-light').style.display = outputLightCheckbox.checked ? 'flex' : 'none';
      document.getElementById('preview-dark').style.display = outputDarkCheckbox.checked ? 'flex' : 'none';
      document.getElementById('preview-ic-light').style.display = outputIcLightCheckbox.checked ? 'flex' : 'none';
      document.getElementById('preview-ic-dark').style.display = outputIcDarkCheckbox.checked ? 'flex' : 'none';
    }

    // Mode button selection
    modeBtns.forEach(btn => {
      btn.onclick = () => {
        modeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedMode = btn.dataset.mode;
        updateColorPreview();
      };
    });

    // Hex input handling
    hexInput.oninput = () => {
      let val = hexInput.value.replace(/[^0-9A-Fa-f]/g, '').toUpperCase();
      if (val.length > 6) val = val.substring(0, 6);
      hexInput.value = val;
      updateColorPreview();
    };

    // Opacity input handling
    opacityInput.oninput = () => {
      let val = parseInt(opacityInput.value) || 100;
      if (val < 1) val = 1;
      if (val > 100) val = 100;
      opacityInput.value = val;
      updateColorPreview();
    };

    // Calculate opacities for all modes based on input opacity (Apple-style multipliers)
    function calculateModeOpacities(baseOpacity, mirrorIc = false) {
      if (baseOpacity === 100) {
        return { Light: 100, Dark: 100, 'IC - Light': 100, 'IC - Dark': 100 };
      }
      const lightOpacity = baseOpacity;
      const darkOpacity = Math.min(100, Math.round(baseOpacity * 1.8));
      
      if (mirrorIc) {
        return {
          Light: lightOpacity,
          Dark: darkOpacity,
          'IC - Light': lightOpacity,
          'IC - Dark': darkOpacity
        };
      }
      return {
        Light: lightOpacity,
        Dark: darkOpacity,
        'IC - Light': Math.min(100, Math.round(baseOpacity * 1.4)),
        'IC - Dark': Math.min(100, Math.round(baseOpacity * 2.2))
      };
    }

    function hexToRgb(hex) {
      if (hex.length !== 6) return null;
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return { r, g, b };
    }

    function rgbToHex(r, g, b) {
      const toHex = (c) => Math.round(Math.max(0, Math.min(1, c)) * 255).toString(16).padStart(2, '0').toUpperCase();
      return toHex(r) + toHex(g) + toHex(b);
    }

    function rgbToHsl(r, g, b) {
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h = 0, s = 0, l = (max + min) / 2;
      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }
      return { h, s, l };
    }

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return { r, g, b };
    }

    function isGrayscale(r, g, b) {
      const hsl = rgbToHsl(r, g, b);
      return hsl.s < 0.05;
    }

    function adjustHsl(r, g, b, lDelta, sDelta) {
      const hsl = rgbToHsl(r, g, b);
      const newL = Math.max(0, Math.min(1, hsl.l + lDelta));
      const newS = Math.max(0, Math.min(1, hsl.s + sDelta));
      return hslToRgb(hsl.h, newS, newL);
    }

    function generateModeColors(inputHex, inputMode, baseOpacity = 100, mirrorIc = false) {
      const rgb = hexToRgb(inputHex);
      if (!rgb) return null;

      // If opacity is not 100%, return same color for all modes (no color transformation)
      if (baseOpacity !== 100) {
        const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
        return {
          Light: hex,
          Dark: hex,
          'IC - Light': hex,
          'IC - Dark': hex
        };
      }

      const grayscale = isGrayscale(rgb.r, rgb.g, rgb.b);
      let lightRgb;

      // First, convert input to Light base
      if (inputMode === 'Light') {
        lightRgb = rgb;
      } else if (grayscale) {
        // Grayscale reverse transformations
        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
        if (inputMode === 'Dark') {
          lightRgb = hslToRgb(hsl.h, hsl.s, 1 - hsl.l); // Invert
        } else if (inputMode === 'IC - Light') {
          lightRgb = hslToRgb(hsl.h, hsl.s, hsl.l + 0.05); // Reverse darken
        } else { // IC - Dark
          lightRgb = hslToRgb(hsl.h, hsl.s, 1 - (hsl.l - 0.05)); // Reverse lighten + invert
        }
      } else {
        // Chromatic reverse transformations
        if (inputMode === 'Dark') {
          lightRgb = adjustHsl(rgb.r, rgb.g, rgb.b, -0.03, 0);
        } else if (inputMode === 'IC - Light') {
          lightRgb = adjustHsl(rgb.r, rgb.g, rgb.b, 0.12, -0.08);
        } else { // IC - Dark
          lightRgb = adjustHsl(rgb.r, rgb.g, rgb.b, -0.15, 0);
        }
      }

      // Generate all 4 modes from Light base
      let results = {};
      if (grayscale) {
        const lightHsl = rgbToHsl(lightRgb.r, lightRgb.g, lightRgb.b);
        results.Light = lightRgb;
        results.Dark = hslToRgb(lightHsl.h, lightHsl.s, 1 - lightHsl.l);
        // Mirror IC modes if enabled
        if (mirrorIc) {
          results['IC - Light'] = results.Light;
          results['IC - Dark'] = results.Dark;
        } else {
          results['IC - Light'] = hslToRgb(lightHsl.h, lightHsl.s, Math.max(0, lightHsl.l - 0.05));
          const darkL = 1 - lightHsl.l;
          results['IC - Dark'] = hslToRgb(lightHsl.h, lightHsl.s, Math.min(1, darkL + 0.05));
        }
      } else {
        results.Light = lightRgb;
        results.Dark = adjustHsl(lightRgb.r, lightRgb.g, lightRgb.b, 0.03, 0);
        // Mirror IC modes if enabled
        if (mirrorIc) {
          results['IC - Light'] = results.Light;
          results['IC - Dark'] = results.Dark;
        } else {
          results['IC - Light'] = adjustHsl(lightRgb.r, lightRgb.g, lightRgb.b, -0.12, 0.08);
          results['IC - Dark'] = adjustHsl(lightRgb.r, lightRgb.g, lightRgb.b, 0.15, 0);
        }
      }

      return {
        Light: rgbToHex(results.Light.r, results.Light.g, results.Light.b),
        Dark: rgbToHex(results.Dark.r, results.Dark.g, results.Dark.b),
        'IC - Light': rgbToHex(results['IC - Light'].r, results['IC - Light'].g, results['IC - Light'].b),
        'IC - Dark': rgbToHex(results['IC - Dark'].r, results['IC - Dark'].g, results['IC - Dark'].b)
      };
    }

    function updateColorPreview() {
      const hex = hexInput.value;
      const baseOpacity = parseInt(opacityInput.value) || 100;
      const mirrorIc = mirrorIcModesCheckbox.checked;
      const opacities = calculateModeOpacities(baseOpacity, mirrorIc);
      
      if (hex.length === 6) {
        colorPreview.style.background = '#' + hex;
        const colors = generateModeColors(hex, selectedMode, baseOpacity, mirrorIc);
        if (colors) {
          const previewLight = document.getElementById('preview-light');
          const previewDark = document.getElementById('preview-dark');
          const previewIcLight = document.getElementById('preview-ic-light');
          const previewIcDark = document.getElementById('preview-ic-dark');
          
          previewLight.style.background = '#' + colors.Light;
          previewDark.style.background = '#' + colors.Dark;
          previewIcLight.style.background = '#' + colors['IC - Light'];
          previewIcDark.style.background = '#' + colors['IC - Dark'];
          
          // Apply opacity to swatches visually
          previewLight.style.opacity = opacities.Light / 100;
          previewDark.style.opacity = opacities.Dark / 100;
          previewIcLight.style.opacity = opacities['IC - Light'] / 100;
          previewIcDark.style.opacity = opacities['IC - Dark'] / 100;
          
          // Update labels to show opacity %
          previewLight.querySelector('span').textContent = baseOpacity === 100 ? 'Light' : `${opacities.Light}%`;
          previewDark.querySelector('span').textContent = baseOpacity === 100 ? 'Dark' : `${opacities.Dark}%`;
          previewIcLight.querySelector('span').textContent = baseOpacity === 100 ? 'IC - L' : `${opacities['IC - Light']}%`;
          previewIcDark.querySelector('span').textContent = baseOpacity === 100 ? 'IC - D' : `${opacities['IC - Dark']}%`;
        }
      } else {
        colorPreview.style.background = '#fff';
        const previewLight = document.getElementById('preview-light');
        const previewDark = document.getElementById('preview-dark');
        const previewIcLight = document.getElementById('preview-ic-light');
        const previewIcDark = document.getElementById('preview-ic-dark');
        
        previewLight.style.background = '#ccc';
        previewDark.style.background = '#ccc';
        previewIcLight.style.background = '#ccc';
        previewIcDark.style.background = '#ccc';
        
        // Reset opacity
        previewLight.style.opacity = 1;
        previewDark.style.opacity = 1;
        previewIcLight.style.opacity = 1;
        previewIcDark.style.opacity = 1;
        
        // Reset labels
        previewLight.querySelector('span').textContent = 'Light';
        previewDark.querySelector('span').textContent = 'Dark';
        previewIcLight.querySelector('span').textContent = 'IC - L';
        previewIcDark.querySelector('span').textContent = 'IC - D';
      }
    }

    // Generate Modes button
    generateModesButton.onclick = () => {
      const hex = hexInput.value;
      const varName = varNameInput.value.trim();
      const collectionId = modeCollectionSelect.value || null;
      const baseOpacity = parseInt(opacityInput.value) || 100;
      const mirrorIc = mirrorIcModesCheckbox.checked;

      if (hex.length !== 6) {
        showMessage(modemakerMessageDiv, 'Please enter a valid 6-digit hex code', 'error');
        return;
      }
      if (!varName) {
        showMessage(modemakerMessageDiv, 'Please enter a variable name', 'error');
        return;
      }

      const colors = generateModeColors(hex, selectedMode, baseOpacity, mirrorIc);
      const opacities = calculateModeOpacities(baseOpacity, mirrorIc);
      const selectedModes = getSelectedOutputModes();
      
      if (selectedModes.length === 0) {
        showMessage(modemakerMessageDiv, 'Please select at least one output mode', 'error');
        return;
      }
      
      parent.postMessage({
        pluginMessage: {
          type: 'generate-mode-colors',
          collectionId,
          varName,
          colors,
          opacities,
          selectedModes
        }
      }, '*');
    };

    function showMessage(element, text, type) {
      element.textContent = text;
      element.className = `message ${type}`;
      element.style.display = 'block';
      
      setTimeout(() => {
        element.style.display = 'none';
      }, 3000);
    }

    // Enable/disable generate button based on selection
    genCollectionSelect.onchange = () => {
      generateButton.disabled = !genCollectionSelect.value;
    };

    // Enable/disable scan button based on selection
    connectCollectionSelect.onchange = () => {
      scanColorsButton.disabled = !connectCollectionSelect.value;
    };

    // Scan Colors button
    scanColorsButton.onclick = () => {
      const collectionId = connectCollectionSelect.value;
      if (!collectionId) return;
      
      suggestionsListDiv.innerHTML = '';
      scanStatsDiv.style.display = 'none';
      
      parent.postMessage({ 
        pluginMessage: { 
          type: 'scan-colors', 
          collectionId 
        } 
      }, '*');
    };

    // Handle connecting a single suggestion
    function connectSuggestion(nodeId, property, varId, element) {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'connect-color', 
          nodeId,
          property,
          varId
        } 
      }, '*');
      element.remove();
      updateSuggestionCount();
    }

    // Skip a suggestion
    function skipSuggestion(element) {
      element.remove();
      updateSuggestionCount();
    }

    // Update suggestion count in stats
    function updateSuggestionCount() {
      const remaining = suggestionsListDiv.children.length;
      if (remaining === 0) {
        scanStatsDiv.textContent = scanStatsDiv.dataset.base + ' | All suggestions handled!';
      }
    }

    // Render suggestions list
    function renderSuggestions(suggestions) {
      suggestionsListDiv.innerHTML = '';
      suggestions.forEach(s => {
        const item = document.createElement('div');
        item.className = 'suggestion-item';
        item.innerHTML = `
          <div class="suggestion-swatch" style="background:rgb(${Math.round(s.color.r*255)},${Math.round(s.color.g*255)},${Math.round(s.color.b*255)})"></div>
          <div class="suggestion-info">
            <div class="suggestion-layer">${s.layerName} (${s.property})</div>
            <div class="suggestion-var">${s.varName}</div>
            <div class="suggestion-delta">Mode: ${s.modeName} | ΔE: ${s.deltaE.toFixed(1)}</div>
          </div>
          <div class="suggestion-actions">
            <button class="btn-small btn-accept" data-node="${s.nodeId}" data-prop="${s.property}" data-var="${s.varId}">Accept</button>
            <button class="btn-small btn-skip">Skip</button>
          </div>
        `;
        
        item.querySelector('.btn-accept').onclick = (e) => {
          const btn = e.target;
          connectSuggestion(btn.dataset.node, btn.dataset.prop, btn.dataset.var, item);
        };
        item.querySelector('.btn-skip').onclick = () => skipSuggestion(item);
        
        suggestionsListDiv.appendChild(item);
      });
    }

    // Create Variables button
    createButton.onclick = () => {
      const collectionId = collectionSelect.value || null;
      parent.postMessage({ 
        pluginMessage: { 
          type: 'create-variables', 
          collectionId 
        } 
      }, '*');
    };

    // Generate Layers button
    const bindVariablesCheckbox = document.getElementById('bind-variables');
    
    generateButton.onclick = () => {
      const collectionId = genCollectionSelect.value;
      if (!collectionId) return;
      
      parent.postMessage({ 
        pluginMessage: { 
          type: 'generate-layers', 
          collectionId,
          bindVariables: bindVariablesCheckbox.checked
        } 
      }, '*');
    };

    // Interpolate Colors button
    interpolateButton.onclick = () => {
      const collectionId = interpolateCollectionSelect.value || null;
      parent.postMessage({ 
        pluginMessage: { 
          type: 'interpolate-colors', 
          collectionId 
        } 
      }, '*');
    };

    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      
      if (msg.type === 'collections') {
        // Save current selections
        const currentValue = collectionSelect.value;
        const currentGenValue = genCollectionSelect.value;
        const currentInterpolateValue = interpolateCollectionSelect.value;
        const currentConnectValue = connectCollectionSelect.value;
        
        // Update create tab dropdown
        collectionSelect.innerHTML = '<option value="">Create new collection</option>';
        msg.collections.forEach(collection => {
          const option = document.createElement('option');
          option.value = collection.id;
          option.textContent = collection.name;
          collectionSelect.appendChild(option);
        });
        
        // Update generate tab dropdown
        genCollectionSelect.innerHTML = '<option value="" disabled>Select a collection</option>';
        msg.collections.forEach(collection => {
          const option = document.createElement('option');
          option.value = collection.id;
          option.textContent = collection.name;
          genCollectionSelect.appendChild(option);
        });

        // Update interpolate tab dropdown
        interpolateCollectionSelect.innerHTML = '<option value="">Create new collection</option>';
        msg.collections.forEach(collection => {
          const option = document.createElement('option');
          option.value = collection.id;
          option.textContent = collection.name;
          interpolateCollectionSelect.appendChild(option);
        });

        // Update mode maker tab dropdown
        const currentModeValue = modeCollectionSelect.value;
        modeCollectionSelect.innerHTML = '<option value="">Create new collection</option>';
        msg.collections.forEach(collection => {
          const option = document.createElement('option');
          option.value = collection.id;
          option.textContent = collection.name;
          modeCollectionSelect.appendChild(option);
        });

        // Update connect tab dropdown
        connectCollectionSelect.innerHTML = '<option value="" disabled>Select a collection</option>';
        msg.collections.forEach(collection => {
          const option = document.createElement('option');
          option.value = collection.id;
          option.textContent = collection.name;
          connectCollectionSelect.appendChild(option);
        });
        
        // Restore selections
        if (currentValue) collectionSelect.value = currentValue;
        if (currentGenValue) {
          genCollectionSelect.value = currentGenValue;
          generateButton.disabled = false;
        }
        if (currentInterpolateValue) interpolateCollectionSelect.value = currentInterpolateValue;
        if (currentModeValue) modeCollectionSelect.value = currentModeValue;
        if (currentConnectValue) {
          connectCollectionSelect.value = currentConnectValue;
          scanColorsButton.disabled = false;
        }
      }
      
      if (msg.type === 'success') {
        showMessage(createMessageDiv, msg.message, 'success');
      }
      
      if (msg.type === 'generate-success') {
        showMessage(generateMessageDiv, msg.message, 'success');
      }
      
      if (msg.type === 'error') {
        showMessage(createMessageDiv, msg.message, 'error');
      }
      
      if (msg.type === 'generate-error') {
        showMessage(generateMessageDiv, msg.message, 'error');
      }

      if (msg.type === 'interpolate-success') {
        showMessage(interpolateMessageDiv, msg.message, 'success');
      }

      if (msg.type === 'interpolate-error') {
        showMessage(interpolateMessageDiv, msg.message, 'error');
      }

      if (msg.type === 'modemaker-success') {
        showMessage(modemakerMessageDiv, msg.message, 'success');
      }

      if (msg.type === 'modemaker-error') {
        showMessage(modemakerMessageDiv, msg.message, 'error');
      }

      if (msg.type === 'scan-success') {
        const baseText = `Auto-connected: ${msg.autoConnected} | Suggestions: ${msg.suggestions.length}`;
        scanStatsDiv.textContent = baseText;
        scanStatsDiv.dataset.base = baseText;
        scanStatsDiv.style.display = 'block';
        renderSuggestions(msg.suggestions);
        if (msg.autoConnected > 0 || msg.suggestions.length > 0) {
          showMessage(connectMessageDiv, `Found ${msg.autoConnected + msg.suggestions.length} colors to connect`, 'success');
        } else {
          showMessage(connectMessageDiv, 'No unbound colors found', 'success');
        }
      }

      if (msg.type === 'scan-error') {
        showMessage(connectMessageDiv, msg.message, 'error');
      }

      if (msg.type === 'connect-success') {
        // Silent success - item already removed from list
      }

      if (msg.type === 'connect-error') {
        showMessage(connectMessageDiv, msg.message, 'error');
      }
    };
  </script>
</body>
</html>
